# Отчет по лабораторной работе task-3

В данной лабораторной работе изучаются основные операции с контейнерами стандартной библиотеки C++, такими как векторы и списки, а также работа с пользовательскими типами данных. Контейнеры используются для хранения и обработки коллекций объектов, в данном случае объектов типа `Number`. Работа включает создание, сортировку, удаление элементов, пересечение контейнеров и другие операции.

## Используемые функции из библиотеки:
1. `generate_n`
    
    Функция `generate_n` используется для генерации последовательности элементов, заполняя контейнер с использованием функции или генератора, который передается как аргумент.
    
2. `back_inserter`

    Функция `back_inserter` создает вставной итератор для контейнера, который добавляет элементы в конец контейнера, используя его метод `push_back`.

3. `partial_sort_copy`

    Функция `partial_sort_copy` копирует и сортирует часть элементов из одного контейнера в другой. В отличие от обычной сортировки, она сортирует `n` наименьших элементов (или наибольших, если использовать обратный компаратор).

4. `remove_if`

    Функция `remove_if` удаляет элементы из контейнера, которые удовлетворяют определенному условию. Важно отметить, что она не изменяет размер контейнера, а сдвигает элементы, которые соответствуют условию, в начало диапазона. После использования remove_if нужно вызвать `erase`, чтобы физически удалить элементы.

5. `erase`

    Функция `erase` удаляет элементы из контейнера. Она может удалить один элемент (по итератору) или диапазон элементов.

6. `accumulate`

    Функция `accumulate` суммирует все элементы в диапазоне. Она принимает два итератора (начало и конец диапазона) и начальное значение аккумулятора.

7. `set_intersection`

    Функция `set_intersection` находит пересечение двух контейнеров. Она копирует в целевой контейнер только те элементы, которые присутствуют в обоих контейнерах.

8. `emplace_back`

    Функция `emplace_back` добавляет новый элемент в конец контейнера, при этом вызывая конструктор элемента на месте. Это позволяет избежать лишних копирований, как это происходит с `push_back`.

9. `reserve`

    Функция `reserve` позволяет заранее выделить место в памяти для указанного числа элементов, чтобы избежать перераспределений памяти при добавлении новых элементов.

## Описание программы с соответствующими логами из консоли:

1. _Создание вектора `v1` с элементами `Number`_

    Cоздается вектор `v1` с элементами типа `Number`. Количество элементов вектора генерируется случайным образом в пределах от 500 до 1000. Каждый элемент инициализируется случайным значением от 1 до 999. Вектор выводится на экран, и отображается его размер.

    ```cpp
    int size_v1 = dist_size(gen);
    std::vector<Number> v1;
    v1.reserve(size_v1);
    std::generate_n(std::back_inserter(v1), size_v1, 
                    [&]() { return Number(dist_value(gen)); });
    ```

    Лог:

        v1 contains: 31 129 971 ... 533 146 73 
        v1 size: 938  

2. _Создание вектора `v2` из последних 200 элементов вектора `v1`_

    Создается новый вектор `v2`, который включает последние 200 элементов из вектора `v1`. Вектор `v2` выводится на экран, и отображается его размер.
    ```cpp
    int b = size_v1 - 200;
    int e = size_v1;
    std::vector<Number> v2(v1.begin() + b, v1.begin() + e);
    ``` 

    Лог:

        v2 contains: 225 850 196 ... 533 146 73
        v2 size: 200 

3. _Создание списка `list1` из `n` наибольших элементов вектора `v1_

    Для создания списка `list1` из наибольших элементов вектора `v1`, выбирается случайное число `n` от 20 до 50. Затем создается временный вектор (так как `partial_sort_copy` не поддерживает списки), в котором хранятся `n` наибольших элементов вектора `v1`, после чего они копируются в список `list1`. Результат выводится на экран.
    ```cpp
    int n = std::uniform_int_distribution<>(20, 50)(gen);
    std::vector<Number> temp_vector1(n);

    std::partial_sort_copy(
        v1.begin(), v1.end(), temp_vector1.begin(), temp_vector1.end(),
        [](const Number &a, const Number &b) { return a.number > b.number; });

    temp_vector1.resize(n);

    std::list<Number> list1(temp_vector1.begin(), temp_vector1.end());
    ```

    Лог:

        list1 contains: 996 996 996 ... 948 948 948 
        list1 size: 46  

4. _Создание списка `list2` из `n` наименьших элементов вектора `v2`_

    Аналогично предыдущему пункту, создается список `list2` из наименьших элементов вектора `v2`. Результат выводится на экран.
    ```cpp
    std::vector<Number> temp_vector2(n);

    std::partial_sort_copy(
        v2.begin(), v2.end(), temp_vector2.begin(), temp_vector2.end(),
        [](const Number &a, const Number &b) { return a.number < b.number; });

    temp_vector2.resize(n);

    std::list<Number> list2(temp_vector2.begin(), temp_vector2.end());
    ```

    Лог:

        list2 contains: 1 1 2 ... 145 146 147
        list2 size: 46 

5. _Удаление перемещенных элементов из `v1` и `v2`_

    После того как элементы были перемещены в `list1` и `list2`, эти элементы удаляются из исходных векторов `v1` и `v2`. Для удаления используется алгоритм `std::remove_if`, который удаляет элементы, равные значениям, находящимся в списках.
    ```cpp
    auto remove_from_vector = [](std::vector<Number> &vec,
                                const std::list<Number> &list) {
        for (const auto &el : list) {
            vec.erase(std::remove_if(
                            vec.begin(), vec.end(),
                            [&](const Number &num) { return num.number == el.number; }),
                        vec.end());
        }
    };
    remove_from_vector(v1, list1);
    remove_from_vector(v2, list2);
    ``` 

    Лог:

        v1 after removal contains: 31 129 330 ... 533 146 73
        v1 size after removal: 892  

        v2 after removal contains: 225 850 196 ... 707 315 533
        v2 size after removal: 154

6. _Перегруппировка `list1` по среднему значению_

    В списке `list1` элементы перегруппировываются относительно среднего значения. Все элементы, большие среднего значения, перемещаются в начало списка.
    ```cpp
    int sum = std::accumulate(
        list1.begin(), list1.end(), 0,
        [](int acc, const Number &num) { return acc + num.number; });

    int avg = sum / list1.size();
    
    list1.sort([avg](const Number &a, const Number &b) {
        return (a.number > avg) && (b.number <= avg);
    });
    ```

    Лог:

        list1 after regrouping contains: 996 996 996 ... 948 948 948
        average for list1: 975

7. _Удаление нечетных элементов из list2_

    Из списка `list2` удаляются все нечетные элементы с помощью метода `remove_if`.
    ```cpp
    list2.remove_if([](const Number &num) { return num.number % 2 != 0; });
    ```

    Лог:

        list2 after removing odd numbers contains: 2 10 20 ... 140 144 146
        list2 size after removing odd numbers: 19  

8. _Создание вектора `v3` из пересечения `v1` и `v2`_

    Вектор `v3` создается как пересечение векторов `v1` и `v2` с использованием алгоритма `std::set_intersection`. Результат выводится на экран.
    ```cpp
    std::vector<Number> v3;
    std::set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(),
                            std::back_inserter(v3));
    ```
    Лог:

        v3 contains: 945

9. _Выравнивание размеров `list1` и `list2` и создание `list3`_

    Размеры списков `list1` и `list2` выравниваются таким образом, чтобы они имели одинаковую длину. После выравнивания создается новый список `list3`, который содержит пары элементов из `list1` и `list2`.
    ```cpp
    if (list1.size() > list2.size()) {
        auto it = list1.begin();
        std::advance(it, list1.size() - list2.size());
        list1.erase(list1.begin(), it);
    } else if (list2.size() > list1.size()) {
        auto it = list2.begin();
        std::advance(it, list2.size() - list1.size());
        list2.erase(list2.begin(), it);
    }
    
    std::list<std::pair<Number, Number>> list3;
    auto it1 = list1.begin(), it2 = list2.begin();

    while (it1 != list1.end() && it2 != list2.end()) {
        list3.emplace_back(*it1++, *it2++);
    }
    ```  

    Лог:

        list3 contains pairs: (971, 2) (970, 10) ... (948, 144) (948, 146)
        list3 size: 19 

10. _Создание списка пар из векторов `v1` и `v2` без выравнивания размеров_

    Создается список пар из векторов v1 и v2, где каждый элемент из v1 комбинируется с соответствующим элементом из v2. Если векторы не одинаковой длины, то добавляются пары только для существующих элементов.
    ```cpp
    std::list<std::pair<Number, Number>> list_pairs;
    auto v1_it = v1.begin();
    auto v2_it = v2.begin();
    while (v1_it != v1.end() && v2_it != v2.end()) {
        list_pairs.emplace_back(*v1_it++, *v2_it++);
    }
    ```

    Лог:

        list_pairs contains pairs: (31, 225) (129, 850) ... (517, 315) (328, 533)
        list_pairs size: 154 

## Заключение:

В ходе выполнения лабораторной работы были реализованы различные операции с контейнерами STL, такие как создание, сортировка, удаление элементов, пересечение контейнеров и выравнивание размеров списков. Работа с контейнерами стандартной библиотеки позволяет эффективно управлять данными и реализовывать различные алгоритмы обработки коллекций.
